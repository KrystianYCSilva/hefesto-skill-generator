# Da Conformidade à Geração Automatizada: Um Guia de Arquitetura para Skills de Agentes de CLI de IA

Este relatório de pesquisa detalhado apresenta um estudo abrangente sobre as melhores práticas para a criação de *habilidades* estruturadas destinadas a interfaces de linha de comando (CLIs) de ferramentas de inteligência artificial. O escopo da investigação abrange as plataformas mencionadas pelo utilizador — Gemini CLI, Claude Code, Qwen Code, Cursor IDE, OpenCode, Codex e GitHub Copilot — bem como outras CLIs de IA emergentes previstas para 2026 que adotem modelos de extensibilidade baseados em *habilidades*. A análise integra diretrizes extraídas da literatura acadêmica formal, incluindo publicações de conferências como IEEE e ACM, com as orientações de comunidades técnicas reconhecidas, tais como documentações oficiais e propostas de melhoria da comunidade (RFCs). O objetivo central é fornecer um quadro robusto e acionável para o desenvolvimento de um sistema automatizado, denominado Heftes, capaz de gerar *habilidades* que sejam conformes, eficientes, seguras e facilmente gerenciáveis. Cada secção deste relatório foi meticulosamente construída com base exclusivamente nas fontes de informação fornecidas, garantindo a fidelidade dos dados e a precisão das análises.

## Fundamentos Conceituais e Evolução do Paradigma de Agentes Agênticos

A concepção e a geração de *habilidades* para CLIs de IA não podem ser compreendidas fora do contexto mais amplo da evolução dos sistemas computacionais interativos, particularmente a transição do paradigma de assistentes passivos para agentes agênticos [[76](https://arxiv.org/html/2503.22625v1), [87](https://www.sciencedirect.com/science/article/pii/S1566253525006712)]. Este movimento representa uma mudança fundamental na forma como os utilizadores e os sistemas de software interagem com os grandes modelos de linguagem (LLMs), transformando-os de simples geradores de texto em entidades proativas com capacidades de tomada de decisão e execução de tarefas autónomas [[5](https://arxiv.org/pdf/2510.04452)]. Uma análise profunda dos princípios subjacentes a esta evolução, derivados da literatura académica e da prática técnica emergente, fornece a base teórica indispensável para a definição de *melhores práticas* sólidas e duradouras para a criação de *habilidades*.

A literatura científica tem sido proeminente na moldar a nossa compreensão destes novos paradigmas. O artigo "AI-Instruments: Embodying Prompts as..." introduz o conceito de "AI-Instrumentos", onde os comandos do utilizador são materializados como objetos de interface tangíveis [[2](https://dl.acm.org/doi/full/10.1145/3706598.3714259)]. Este princípio, fundamentado em três pilares — reificação da intenção do utilizador, reflexão e ancoragem — oferece um modelo poderoso para a conceção de *habilidades*. A "reificação da intenção" sugere que uma *habilidade* bem projetada deve encapsular uma intenção específica e finamente granular, tornando-a um objeto de conhecimento autocontido e descritível. Os metadados de uma *habilidade*, portanto, deixam de ser meras etiquetas para se tornarem a manifestação física dessa intenção, descrevendo o que a *habilidade* faz, para quem serve e sob quais condições deve ser ativada. Esta abordagem alinha-se perfeitamente com a necessidade de criar *habilidades* modularizadas, como descrito no artigo "Agent Skills" [[86](https://zhuanlan.zhihu.com/p/2002045828500575394)], que define habilidades como unidades funcionais modulares que permitem aos agentes dinamicamente carregar capacidades específicas para executar tarefas complexas, mitigando assim problemas como a saturação de contexto [[27](https://www.linkedin.com/posts/throusse_everyone-customizing-claude-code-and-similar-activity-7419477521609662464-XEcp)].

A crescente sofisticação dos agentes agênticos é frequentemente explorada em frameworks multi-agente. O artigo "Multi-Agent Framework Utilizing Large Language Models" descreve um framework para simular participantes humanos e tentar resolver autonomamente problemas comuns de segurança (CTF) [[6](https://www.mdpi.com/2076-3417/15/13/7159)]. Da mesma forma, "Jupybara: Operationalizing a Design Space for Actionable..." apresenta um assistente AI baseado em LLMs para Análise Exploratória de Dados (EDA) e contação de histórias, operacionalizando um espaço de design para ações concretas [[4](https://dl.acm.org/doi/full/10.1145/3706598.3713913)]. Estes trabalhos demonstram que a complexidade das tarefas que os agentes estão aptos a enfrentar exige uma arquitetura altamente modular e especializada. As *habilidades* são o mecanismo chave para alcançar este nível de especialização. Elas permitem que um agente principal delegue tarefas específicas a componentes dedicados, cada um com seu próprio conjunto de ferramentas, conhecimento e lógica de execução. A distinção entre *habilidades* e *regras* é elucidativa neste ponto; enquanto as *habilidades* são funcionalidades reutilizáveis e orquestráveis, as *regras* definem o comportamento e as restrições dentro das quais essas *habilidades* operam [[84](https://www.showapi.com/news/article/697a43b24ddd79ab6710fff0)]. Esta separação de preocupações é uma boa prática de engenharia de software clássica aplicada a um domínio moderno.

O campo académico também contribuiu com taxonomias que ajudam a classificar e a entender melhor a diversidade de agentes e suas capacidades. A "LLMOrbit: A Circular Taxonomy of Large Language Models" oferece uma análise técnica detalhada de mais de 50 modelos importantes entre 2019 e 2025, documentando suas características fundamentais [[73](https://arxiv.org/html/2601.14053v1)]. Embora seja focada nos modelos de linguagem, uma taxonomia semelhante pode ser extrapolada para os sistemas de agentes, classificando-os por dimensões como autonomia, capacidade de aprendizagem, modalidade de interação e domínio de aplicação. Outros trabalhos, como "Toward a Digital Ecosystem for Additive Manufacturing" [[64](https://ieeexplore.ieee.org/iel8/6287639/10820123/11282428.pdf)] e "A Survey on Information and Communication Technologies in Automotive Embedded Systems" [[18](https://ieeexplore.ieee.org/iel7/6287639/10005208/10177956.pdf)], ilustram a aplicação de sistemas de agentes e IA em domínios industriais complexos, reforçando a necessidade de *habilidades* especializadas para lidar com protocolos, APIs e fluxos de trabalho específicos da indústria.

Além da sua natureza funcional, a confiança e a explicabilidade são temas centrais na pesquisa sobre IA responsável. O artigo "A Review of Trustworthy and Explainable Artificial Intelligence" destaca a importância de proteger a confidencialidade de informações sensíveis e de tornar os sistemas de IA transparentes e justificáveis [[29](https://ieeexplore.ieee.org/iel7/6287639/10005208/10188681.pdf)]. No contexto de *habilidades* para CLIs, isto implica que as *habilidades* devem ser concebidas desde o início com princípios de segurança e auditabilidade. Por exemplo, ao gerar scripts que interagem com APIs externas ou manipulam ficheiros locais, a *habilidade* deve incorporar verificações de segurança e registos claros do que está a fazer e porquê. A literatura sobre ataques de injecção de comandos, como o artigo "Prompt Injection Attacks on Agentic Coding Assistants" [[28](https://arxiv.org/html/2601.17548v1)], serve como um lembrete crítico de que os agentes de código são vulneráveis a entradas maliciosas. Portanto, uma *habilidade* robusta não deve apenas executar uma função, mas também validar cuidadosamente a sua entrada e limitar o seu acesso a recursos sempre que possível, seguindo o princípio do menor privilégio.

A própria interação humana-computador está a ser repensada nesta nova era. "Generative Theories of Interaction" propõe teorias que se inspiram em teorias empíricas sobre o comportamento humano para definir conceitos específicos no domínio da interação [[8](https://dl.acm.org/doi/full/10.1145/3468505)]. Aplicado à conceção de *habilidades*, isso significa que as *habilidades* devem ser projetadas para se integrarem fluentemente no fluxo de trabalho do utilizador, respondendo de forma intuitiva e previsível. A qualidade de uma *habilidade* não é medida apenas pela sua correção funcional, mas também pela sua usabilidade e pela forma como enriquece a experiência do utilizador. Princípios como a "reflexão", outro pilar de "AI-Instruments" [[2](https://dl.acm.org/doi/full/10.1145/3706598.3714259)], sugerem que a *habilidade* deveria, quando apropriado, fornecer feedback sobre o seu próprio estado ou sobre o processo que está a utilizar, permitindo ao utilizador compreender e ajustar a sua interação com o agente.

Em suma, a literatura académica consolida um conjunto de princípios fundamentais que devem guiar a criação de *habilidades* para CLIs de IA:
1.  **Modularidade e Reuso:** As *habilidades* devem ser unidades funcionais auto-contidas e reutilizáveis, facilitando a construção de agentes complexos a partir de componentes mais simples e testáveis [[84](https://www.showapi.com/news/article/697a43b24ddd79ab6710fff0), [86](https://zhuanlan.zhihu.com/p/2002045828500575394)].
2.  **Reificação da Intenção:** Os metadados e a estrutura de uma *habilidade* devem refletir claramente a sua finalidade, tornando-a um objeto de conhecimento descritível e selecionável pelo agente [[2](https://dl.acm.org/doi/full/10.1145/3706598.3714259)].
3.  **Segurança e Verificabilidade:** As *habilidades* devem ser concebidas com segurança intrínseca, validando entradas e limitando privilégios para mitigar riscos como ataques de injecção [[28](https://arxiv.org/html/2601.17548v1), [29](https://ieeexplore.ieee.org/iel7/6287639/10005208/10188681.pdf)].
4.  **Descritividade e Auto-documentação:** Uma *habilidade* bem-sucedida é autoexplicativa. A sua descrição, metadados e exemplos devem ser tão claros que permitam ao agente e ao utilizador compreenderem o seu propósito e modo de operação sem necessidade de recorrer a documentação externa [[8](https://dl.acm.org/doi/full/10.1145/3468505)].
5.  **Especialização e Domínio:** À medida que os agentes se tornam mais capazes, a especialização das *habilidades* torna-se crucial para a eficácia. *Habilidades* dedicadas a tarefas específicas (ex: gestão de dependências num framework particular, geração de queries SQL para um banco de dados específico) serão mais eficientes e precisas do que *habilidades* genéricas [[27](https://www.linkedin.com/posts/throusse_everyone-customizing-claude-code-and-similar-activity-7419477521609662464-XEcp)].

Estes princípios formam a base teórica sobre a qual as melhores práticas de implementação, que serão discutidas nas secções subsequentes, podem ser construídas. Ignorar estas fundações resultará numa geração de *habilidades* que, embora possam funcionar superficialmente, carecerão de robustez, segurança e escalabilidade, falhando em aproveitar todo o potencial do paradigma de agentes agênticos.

## Conformidade com Documentação Oficial e Mecanismos de Extensibilidade por Plataforma

A conformidade com a documentação oficial de cada CLI de IA é o pilar fundamental que garante a interoperabilidade, a funcionalidade e a manutenibilidade das *habilidades* geradas. O requisito explícito de seguir as diretrizes de cada plataforma, seja ela Google, Anthropic, Microsoft ou uma ferramenta de código-fonte aberto emergente, não é opcional, mas uma necessidade técnica primária. A análise das fontes disponíveis revela que, embora exista uma tendência para a padronização através de protocolos como MCP [[25](https://blog.csdn.net/EnjoyEDU/article/details/155378733), [69](https://www.53ai.com/news/LargeLanguageModel/2025040889057.html)], cada ecossistema possui mecanismos de extensibilidade únicos e específicos. Portanto, um sistema de geração automatizada de *habilidades* deve ser concebido como um motor que consome as especificações de cada plataforma e gera artefactos compatíveis, em vez de procurar um padrão universal que não existe ainda.

Para a **Claude Code**, a documentação indica um sistema de extensibilidade sofisticado baseado em manifestos e ganchos. O guia técnico definitivo menciona a existência de um `manifest file` que define domínios através de palavras-chave de gatilho [[27](https://www.linkedin.com/posts/throusse_everyone-customizing-claude-code-and-similar-activity-7419477521609662464-XEcp)]. Este arquivo, presumivelmente em formato JSON ou YAML, serve como o ponto de entrada para a carga de funcionalidades adicionais. Além disso, a customização avançada é alcançada através de um `hook` em Python, que é executado em cada pedido ao agente. Este gancho analisa o pedido, identifica as palavras-chave relevantes e injeta dinamicamente apenas as regras ou conhecimentos pertinentes [[27](https://www.linkedin.com/posts/throusse_everyone-customizing-claude-code-and-similar-activity-7419477521609662464-XEcp)]. Esta abordagem é particularmente eficaz para combater o problema da "context bloat" (saturação de contexto), onde a inclusão de demasiada informação no prompt reduz a eficácia do modelo [[27](https://www.linkedin.com/posts/throusse_everyone-customizing-claude-code-and-similar-activity-7419477521609662464-XEcp)]. Para gerar uma *habilidade* que funcione com Claude Code, o projeto Heftes deve ser capaz de gerar um `manifest.json` válido e, opcionalmente, um script de gancho Python mínimo que saiba como carregar e ativar essa *habilidade*. A documentação completa do Claude Code CLI é citada como um recurso essencial para entender todos os campos e opções disponíveis neste manifesto [[53](https://blakecrosley.com/en/guides/claude-code)].

No caso do **GitHub Copilot**, o ecossistema é profundamente integrado com as funcionalidades do GitHub, utilizando o GitHub Model Context Protocol (MCP) para interagir com recursos do GitHub, como repositórios, issues e pull requests [[23](https://docs.github.com/en/copilot/how-tos/provide-context/use-mcp/use-the-github-mcp-server)]. Isto sugere que as *habilidades* para o Copilot podem não ser meros blocos de código, mas sim clientes ou servidores MCP especializados. Um artigo sobre a API do MCP detalha como interagir com estas entidades [[23](https://docs.github.com/en/copilot/how-tos/provide-context/use-mcp/use-the-github-mcp-server)]. Adicionalmente, o GitHub Spec Kit promove o desenvolvimento guiado por especificação (Spec-Driven Development), indicando que a conformidade pode envolver a geração de código que respeite templates e padrões de interface específicos definidos pelo GitHub [[78](https://developer.microsoft.com/blog/spec-driven-development-spec-kit)]. A documentação oficial do Copilot CLI destaca a sua capacidade de usar o sinalizador `@` para adicionar o conteúdo de ficheiros ao contexto do pedido, por exemplo, `Explain @config/ci/ci-required-checks.yml` [[80](https://docs.github.com/en/copilot/how-tos/copilot-cli/use-copilot-cli)]. Uma *habilidade* bem-sucedida para o Copilot deve, portanto, ser gerada de forma a poder ser chamada de forma compatível com esta sintaxe e a produzir uma saída que o agente possa interpretar corretamente. A documentação oficial cobre planos de subscrição, como Pro, Business e Enterprise, que determinam o acesso a certas funcionalidades, como o coding agent [[12](https://docs.github.com/en/copilot/concepts/agents/coding-agent/about-coding-agent)].

Para o **Gemini CLI**, a documentação posiciona-o como uma poderosa ferramenta de agente de IA que pode ser usada para uma variedade de tarefas, incluindo a análise e correção de código [[1](https://realpython.com/how-to-use-gemini-cli/)]. Um artigo destaca a sua capacidade de gerar instruções SQL complexas e exportar dados, sendo utilizado para "desenvolvimento de aplicações simplificado com bases de dados" [[22](https://www.tiktok.com/@cloudwithkarl/video/7519879044079340855)]. Outra fonte refere-o como uma ferramenta de IA gratuita que compete com outras [[24](https://www.linkedin.com/posts/reidkimball_build-debug-deploy-with-ai-activity-7417322614400151552-ls2z)]. Embora a documentação específica para a extensibilidade via *habilidades* não seja detalhada nas fontes fornecidas, a geração de *habilidades* para o Gemini CLI deve focar-se em replicar e expandir estas funcionalidades declaradas. O projeto Heftes deve ser capaz de gerar scripts ou configurações que explorem as capacidades documentadas do Gemini CLI, possivelmente através da sua API ou da sua linha de comando nativa.

A situação do **Qwen Code** e do **Cursor IDE** é interessante porque eles estão frequentemente entrelaçados nas discussões técnicas. Há um tutorial que demonstra como criar uma versão "full-blooded Claude Code" usando o Qwen3 como modelo de linguagem [[79](https://blog.csdn.net/sinat_37574187/article/details/149577227)]. Isso sugere que o Qwen Code pode ser visto como uma alternativa ou um complemento ao Claude Code, possivelmente com um mecanismo de extensibilidade similar. Por outro lado, o Cursor é um editor de código que integra diretamente um assistente de IA e há discussões sobre a sua capacidade de integrar-se com servidores MCP [[40](https://www.linkedin.com/posts/sonnylazuardi_just-wanted-to-share-my-latest-experiment-activity-7307821553654657024-yrh8)]. Isto sugere que o Cursor pode funcionar como um cliente para *habilidades* implementadas como servidores MCP. Portanto, a geração de *habilidades* para estas plataformas pode envolver a criação de diferentes tipos de artefactos: um pacote de extensibilidade para Qwen Code (sempre que a documentação ficar disponível) e um servidor MCP para o Cursor.

Outras ferramentas como o **OpenCode** e o **Codex** também operam dentro deste novo paradigma. O Codex, em particular, é frequentemente mencionado no contexto do Model Context Protocol (MCP) [[25](https://blog.csdn.net/EnjoyEDU/article/details/155378733)]. Comparar o código-fonte do Gemini CLI com o do Codex ajuda a entender como o MCP é usado para a interação entre a ferramenta e as suas ferramentas [[25](https://blog.csdn.net/EnjoyEDU/article/details/155378733)]. O MCP é descrito como um protocolo que desacopla a interação com a ferramenta da implementação da funcionalidade, o que é um princípio fundamental para a modularidade e a escalabilidade [[69](https://www.53ai.com/news/LargeLanguageModel/2025040889057.html)]. Assim, uma *habilidade* bem-arquitetada para o Codex seria provavelmente um programa que implementa um servidor MCP, exposto em uma URL, que o Codex pode consultar para obter resultados.

A tabela seguinte resume os mecanismos de extensibilidade identificados e as implicações para a geração de *habilidades*:

| Plataforma | Mecanismo de Extensibilidade Identificado | Implicações para a Geração de Habilidades (Heftes) |
| :--- | :--- | :--- |
| **Claude Code** | `manifest.json` para domínios/gatilhos e ganchos Python para lógica dinâmica [[27](https://www.linkedin.com/posts/throusse_everyone-customizing-claude-code-and-similar-activity-7419477521609662464-XEcp), [53](https://blakecrosley.com/en/guides/claude-code)]. | Gerar um arquivo `manifest.json` válido e um script de gancho Python que carregue a lógica da habilidade. |
| **GitHub Copilot** | GitHub Model Context Protocol (MCP) para interagir com recursos do GitHub [[23](https://docs.github.com/en/copilot/how-tos/provide-context/use-mcp/use-the-github-mcp-server)]; uso de `@file` para contexto [[80](https://docs.github.com/en/copilot/how-tos/copilot-cli/use-copilot-cli)]. | Gerar clientes/servidores MCP ou scripts que funcionem com a sintaxe de contexto `@`. |
| **Gemini CLI** | Capacidade documentada para gerar SQL, exportar dados e ajudar na análise de código [[1](https://realpython.com/how-to-use-gemini-cli/), [22](https://www.tiktok.com/@cloudwithkarl/video/7519879044079340855)]. | Gerar scripts ou configurações que explorem as funcionalidades declaradas, possivelmente via API ou linha de comando. |
| **Qwen Code** | Informação insuficiente nas fontes fornecidas; pode ter mecanismo semelhante ao Claude Code [[79](https://blog.csdn.net/sinat_37574187/article/details/149577227)]. | A geração de *habilidades* dependerá da disponibilidade de documentação futura sobre a sua extensibilidade. |
| **Cursor IDE** | Funciona como cliente para agentes e ferramentas; integração com servidores MCP [[40](https://www.linkedin.com/posts/sonnylazuardi_just-wanted-to-share-my-latest-experiment-activity-7307821553654657024-yrh8)]. | Gerar um servidor MCP que o Cursor possa ligar para obter funcionalidades adicionais. |
| **Codex** | Uso do Model Context Protocol (MCP) para a interação com ferramentas [[25](https://blog.csdn.net/EnjoyEDU/article/details/155378733), [69](https://www.53ai.com/news/LargeLanguageModel/2025040889057.html)]. | Gerar um servidor MCP que implemente a lógica da *habilidade* e seja consultado pelo Codex. |

A conclusão desta secção é inequívoca: não existe uma única solução "tamanho único". Em vez disso, a conformidade com a documentação oficial de cada plataforma é o critério decisivo. O projeto Heftes deve ser construído sobre uma arquitetura de motor que utilize "drivers" ou plugins específicos para cada CLI. Cada driver seria responsável por conhecer os formatos de ficheiro, os protocolos e os requisitos de configuração da sua plataforma-alvo. O modelo de *habilidade* fornecido pelo utilizador (`SKILL.template.md`) pode servir como um esquema de nível superior abstrato, mas o verdadeiro desafio reside em mapear adequadamente este esquema para as especificações concretas de cada plataforma. Esta abordagem garante que o sistema seja escalável e resiliente às mudanças, pois novas plataformas podem ser adicionadas simplesmente implementando um novo driver, sem afetar o núcleo do motor de geração.

## Estruturação de Metadados e Organização de Conteúdo Modular

A criação de *habilidades* estruturadas vai além da mera implementação da lógica funcional; exige uma abordagem deliberada à organização e à descrição desses artefactos. A estruturação com metadados adequados e uma organização de diretórios lógica são cruciais para a manutenibilidade, a reutilização e a descoberta de *habilidades* por parte de agentes e utilizadores. O pedido do utilizador de seguir um template com nove campos de metadados obrigatórios é uma excelente proposta inicial de padronização, mas a flexibilidade para adaptar categorias e subcategorias, conforme confirmado na conversa, é igualmente importante para se adequar às nuances de cada CLI. A literatura académica e as melhores práticas de engenharia de software fornecem um rico contexto para refinarmos este processo.

O modelo de metadados proposto, com nove campos, serve como um excelente esquema de nível superior. Embora os nomes exatos dos campos não sejam detalhados nas fontes fornecidas, podemos inferir os seus conteúdos com base nos princípios de descritividade e auto-documentação. Trabalhos como "Generative Theories of Interaction" [[8](https://dl.acm.org/doi/full/10.1145/3468505)] e "AI-Instruments: Embodying Prompts as..." [[2](https://dl.acm.org/doi/full/10.1145/3706598.3714259)] enfatizam a importância de tornar a intenção do utilizador explícita e manipulável. Os metadados de uma *habilidade* são, em última análise, a expressão formal dessa intenção. Um conjunto de metadados robusto deve responder a perguntas fundamentais: quem criou esta *habilidade*? Para que tarefas ela é adequada? Que tecnologias ou dependências utiliza? Quais são os seus objetivos e limitações? Como pode ser testada?

A flexibilidade para adaptar categorias e subcategorias, conforme a natureza específica de cada CLI, é uma recomendação estratégica. Por exemplo, a documentação do Claude Code menciona a definição de "domains" com "keyword triggers" em um `manifest file` [[27](https://www.linkedin.com/posts/throusse_everyone-customizing-claude-code-and-similar-activity-7419477521609662464-XEcp)]. Neste caso, a categoria/subcategoria da *habilidade* no nosso esquema abstrato seria traduzida diretamente para o campo `domains` no ficheiro `manifest.json`. Por outro lado, se outra plataforma usar uma nomenclatura diferente, como `categories` ou `tags`, o motor de geração deve ser capaz de realizar essa tradução. Esta abstração permite-nos manter um único modelo de concepção da *habilidade* enquanto geramos artefactos específicos para múltiplas plataformas. A capacidade de agrupar *habilidades* logicamente (por exemplo, `category: 'database'`, `subcategory: 'sql-generation'`) facilita enormemente a seleção por parte do agente, que pode então carregar dinamicamente um subconjunto de *habilidades* relevantes para o problema imediato, otimizando o uso de recursos e o tempo de resposta.

A organização de diretórios é o segundo pilar desta estruturação. Uma *habilidade* não deve ser um ficheiro monolítico, mas um pequeno pacote de conteúdo coeso. Uma estrutura de diretório recomendada para uma *habilidade* poderia ser a seguinte:

```
skills/
└── my-awesome-skill/
    ├── skill.yaml          # Metadados principais (o nosso template abstrato)
    ├── manifest.json       # Ficheiro de manifesto para a plataforma-alvo (ex: Claude Code)
    ├── main.py             # Script principal da habilidade (lógica de execução)
    └── content/            # Conteúdo complementar (exemplos, tutoriais)
        ├── examples/
        ├── references/
        └── benchmarks/
```

Esta estrutura desacopla a descrição da *habilidade* (`skill.yaml`) da sua implementação específica para uma plataforma (`manifest.json`) e da sua lógica (`main.py`). O diretório `content/` prepara o terreno para a implementação do carregamento sob demanda, como será discutido na secção seguinte. Esta organização modular não só torna a *habilidade* mais fácil de navegar e compreender, mas também facilita a automação da sua criação e atualização pelo sistema Heftes.

A escolha do formato dos metadados é também uma consideração importante. O YAML é um formato popular para metadados devido à sua legibilidade por humanos e facilidade de escrita. O template fornecido pelo utilizador usa YAML para o frontmatter [[70](https://mirrors.aliyun.com/pypi/simple/)]. No entanto, algumas plataformas podem exigir outros formatos, como JSON ou TOML. O motor de geração deve ser capaz de serializar o mesmo modelo de dados em diferentes formatos, dependendo do requisito da plataforma-alvo. Por exemplo, o campo `author` no nosso modelo YAML seria convertido para `"author": "..."` num ficheiro JSON ou `author = "..."` num ficheiro TOML.

A literatura de base, embora não contenha um manual de estilo para metadados de *habilidades*, apoia firmemente a filosofia por trás desta abordagem. O artigo "Application of Category Theory to Network Service Fault Management" utiliza a teoria das categorias para modelar serviços de rede, destacando a importância de capturar dados e metadados de forma sistemática [[15](https://ieeexplore.ieee.org/iel8/8782661/10362961/10592034.pdf)]. Embora o domínio seja diferente, o princípio de que a estrutura e a descrição são cruciais para a gestão e orquestração de componentes é universal. Da mesma forma, a taxonomia de sistemas de agricultura inteligente baseada em IA [[35](https://ieeexplore.ieee.org/iel7/6287639/10005208/09999442.pdf)] e a taxonomia de modelos de linguagem [[73](https://arxiv.org/html/2601.14053v1)] demonstram a importância de classificar e descrever sistemas complexos de forma hierárquica e consistente.

A seguir, apresentamos uma tabela com propostas de campos de metadados para o nosso esquema abstrato, inspiradas nas melhores práticas de engenharia de software e na literatura sobre IA:

| Campo de Metadados (Proposta) | Tipo | Descrição | Exemplo |
| :--- | :--- | :--- | :--- |
| `name` | String | Nome único e descritivo da *habilidade*. | `generate-complex-sql` |
| `description` | Texto Longo | Uma descrição detalhada do que a *habilidade* faz, os seus objetivos e as suas limitações. | "Esta habilidade gera declarações SQL complexas a partir de uma descrição natural, incluindo junções, agregações e subconsultas." |
| `author` | String | O nome e/ou contacto do autor ou organização que criou a *habilidade*. | "João Silva <joao.silva@email.com>" |
| `version` | SemVer | A versão da *habilidade* no formato SemVer (ex: 1.2.3). | `1.0.0` |
| `license` | String | A licença sob a qual a *habilidade* é distribuída (ex: MIT, Apache-2.0). | `MIT` |
| `category` | String | Uma categoria principal de alto nível para a *habilidade*. | `database` |
| `subcategory` | String | Uma subcategoria mais específica dentro da categoria. | `query-generation` |
| `dependencies` | Array[String] | Uma lista de dependências (bibliotecas, ferramentas externas) necessárias para a *habilidade*. | `["python>=3.8", "sqlglot"]` |
| `platforms` | Array[String] | Uma lista das plataformas (CLIs) para as quais esta *habilidade* pode ser gerada. | `["claudocode", "githubcopilot"]` |
| `example_prompt` | String | Um exemplo de comando ou prompt que o utilizador poderia inserir para invocar a *habilidade*. | `Gerar SQL para listar os 10 clientes com mais pedidos no último ano.` |
| `test_cases` | Array[Object] | Uma lista de casos de teste para validar o funcionamento da *habilidade*. | `[{"input": "...", "expected_output": "..."}]` |

Esta estrutura de metadados, combinada com uma organização de diretórios modular, cria um produto final robusto e auto-descritivo. O sistema Heftes, ao gerar uma *habilidade*, não produz apenas código funcional, mas um artefacto completo que é fácil de gerir, auditar e compartilhar. A flexibilidade para adaptar as categorias permite que esta estrutura abstrata se aplique a uma vasta gama de CLIs, desde os já existentes até aos emergentes em 2026, tornando o projeto sustentável e resiliente ao longo do tempo.

## Carregamento Just-in-Time (JIT) e Gestão de Conteúdos Complementares

A estratégia de carregamento sob-demanda (JIT - Just-in-Time) de conteúdo complementar, como exemplos, referências e informações adicionais, é uma das práticas mais inovadoras e potentes delineadas no pedido de pesquisa. Esta abordagem visa desacoplar o núcleo leve e rápido da *habilidade* da sua massa de contexto e conhecimento, carregando este último apenas quando necessário. Tal estratégia promove uma maior eficiência de desempenho, reduzindo o tempo de inicialização e o consumo de recursos do agente, ao mesmo tempo que facilita a manutenção e a colaboração, ao permitir que o conteúdo auxiliar seja gerido independentemente. A implementação desta funcionalidade requer uma abordagem deliberada tanto na estruturação da *habilidade* como na arquitetura subjacente que a suporta.

A ideia de JIT para *habilidades* é análoga a conceitos estabelecidos em sistemas de programação e redes de computadores. Na programação, a carga tardia de módulos ou bibliotecas é uma técnica comum para acelerar o arranque de aplicações. Na área de redes, a gestão de eventos em filas organizadas por tempo de execução planeado demonstra a eficiência de processar informações apenas quando o momento certo chega [[38](https://ieeexplore.ieee.org/iel7/6287639/10380310/10423007.pdf)]. No contexto das *habilidades*, o núcleo da *habilidade* (com os seus metadados e a lógica mínima de invocação) é carregado imediatamente. Quando o agente decide ativar a *habilidade*, o seu script principal, em vez de conter toda a documentação e os exemplos, contém lógica para buscar estes conteúdos adicionais a partir de localizações externas, geralmente especificadas através de URLs nos seus metadados.

A diretriz `JIT-PROTOCOL.md` parece ser o documento mais relevante para definir este padrão, embora o seu conteúdo específico não esteja disponível nas fontes fornecidas [[70](https://mirrors.aliyun.com/pypi/simple/)]. Baseado no princípio geral, podemos deduzir os passos para a sua implementação. O sistema Heftes, ao gerar uma *habilidade*, deve criar um manifesto de conteúdo JIT. Este manifesto pode ser um ficheiro separado (ex: `jit-manifest.json`) ou ser incorporado diretamente nos metadados da *habilidade*. Este manifesto listaria URLs para os vários tipos de conteúdo complementar. Por exemplo:

```json
{
  "examples_url": "https://gist.github.com/.../sql-examples-gist-id",
  "tutorial_url": "https://docs.company.com/skills/generate-sql-v1/tutorial.html",
  "references_urls": [
    "https://www.postgresql.org/docs/",
    "https://sqlite.org/lang.html"
  ],
  "benchmarks_url": "https://github.com/user/my-awesome-skill-benchmarks"
}
```

A implementação do carregamento JIT seria responsabilidade do agente CLI final, mas o Heftes garante que o material necessário esteja bem estruturado e acessível através de links. Quando a *habilidade* é ativada, o script da *habilidade* faria chamadas de rede HTTP/HTTPS para recuperar estes conteúdos. Esta recuperação poderia ser síncrona (bloqueante) se a informação for pequena e crítica para a execução imediata, ou assíncrona (não bloqueante), onde a informação é buscada em segundo plano e apresentada ao utilizador após a conclusão da tarefa principal.

As fontes fornecidas oferecem várias pistas sobre onde armazenar e como gerir este conteúdo complementar. O GitHub emerge como uma plataforma central para a colaboração e versionamento. A capacidade de criar *gists* públicos ou secretos [[47](https://docs.github.com/en/enterprise-server@3.18/get-started/writing-on-github/editing-and-sharing-content-with-gists/creating-gists)] é uma ferramenta excelente para compartilhar blocos de código curtos, exemplos ou snippets de configuração. Um utilizador pode criar um gist com exemplos de SQL e depois inserir o link para esse gist nos metadados da *habilidade*. Outra funcionalidade útil é a capacidade de dar "star" a um gist, o que o marca como favorito e fácil de encontrar novamente [[48](https://docs.github.com/en/enterprise-server@3.14/get-started/writing-on-github/editing-and-sharing-content-with-gists/saving-gists-with-stars)]. Para conteúdo mais extenso, como tutoriais completos ou documentação de referência, um repositório Git dedicado seria mais apropriado. A adoção de práticas de controlo de versões robustas, como o *signing commits* e *tags* usando GPG ou SSH, aumenta significativamente a confiança no conteúdo [[41](https://docs.github.com/en/authentication/managing-commit-signature-verification/signing-commits), [42](https://docs.github.com/en/authentication/managing-commit-signature-verification/signing-tags), [44](https://docs.github.com/en/authentication/managing-commit-signature-verification/about-commit-signature-verification), [45](https://docs.github.com/en/enterprise-server@3.18/authentication/managing-commit-signature-verification/about-commit-signature-verification)]. Um utilizador que gera uma *habilidade* com o Heftes deve ser encorajado a assinar os seus commits e tags ao partilhar o conteúdo complementar, permitindo que outros verifiquem a origem e a integridade do material.

A relação entre o JIT e os protocolos subjacentes, como o MCP (Model Context Protocol), é provavelmente muito forte. O MCP é um protocolo projetado para a interação estruturada entre um modelo de linguagem e as suas ferramentas [[25](https://blog.csdn.net/EnjoyEDU/article/details/155378733), [69](https://www.53ai.com/news/LargeLanguageModel/2025040889057.html)]. Um servidor MCP pode não apenas expor uma função, mas também a sua documentação, exemplos e outras metainformações. Portanto, a implementação de uma *habilidade* como um servidor MCP nativo pode ser a maneira mais elegante de habilitar o JIT. O agente CLI (como o Gemini CLI ou o Codex) poderia fazer uma chamada ao servidor MCP para não só executar a habilidade, mas também para obter a sua "carta de condução" — uma descrição completa da sua interface e funcionalidades. Esta descrição poderia, por sua vez, conter links para documentação externa, tutoriais e benchmarks, implementando assim o JIT de forma integrada e nativa ao protocolo. Artigos que descrevem a implementação de servidores e clientes MCP [[69](https://www.53ai.com/news/LargeLanguageModel/2025040889057.html)] e a utilização do MCP para interagir com ferramentas de codificação [[54](https://www.linkedin.com/posts/jeffreyemanuel_github-dicklesworthstonemcpagentmail-activity-7388557611622903808-oh0H)] fornecem um roteiro prático para esta abordagem.

A seguir, apresentamos uma tabela que descreve os tipos de conteúdo complementar, os seus formatos recomendados e as melhores práticas para o seu armazenamento e partilha:

| Tipo de Conteúdo | Formato Recomendado | Melhor Prática de Armazenamento | Rationale |
| :--- | :--- | :--- | :--- |
| **Exemplos de Uso** | Markdown, Código Fonte (ficheiros .py, .js, etc.) | *Gists* do GitHub públicos ou partes de um repositório dedicado. | Fácil de criar, partilhar e referenciar. Permite edição colaborativa. [[47](https://docs.github.com/en/enterprise-server@3.18/get-started/writing-on-github/editing-and-sharing-content-with-gists/creating-gists), [48](https://docs.github.com/en/enterprise-server@3.14/get-started/writing-on-github/editing-and-sharing-content-with-gists/saving-gists-with-stars)] |
| **Tutoriais Passo-a-Passo** | HTML/Página Web, Markdown | Página de documentação num site (ex: Read the Docs) ou wiki de um repositório. | Ideal para conteúdo narrativo e visual. Facilita a aprendizagem. |
| **Documentação de Referência** | HTML/Página Web, Ficheiros Manuais | Site de documentação público ou ficheiros PDF/HTML autocontidos. | Fornece detalhes técnicos completos sobre a API ou a funcionalidade da *habilidade*. |
| **Casos de Teste / Benchmarks** | Ficheiros YAML/JSON, Código de Teste | Repositório Git dedicado ou diretório `tests/` num repositório principal. | Permite a automação da validação da *habilidade*. Garante a sua correção ao longo do tempo. |
| **Informação Adicional / Artigos** | PDF, Blog Post, Link para Artigo | Link para o artigo original ou ficheiro PDF anexado. | Fornece contexto histórico ou teórico sobre o problema que a *habilidade* resolve. |

Implementar esta estratégia de JIT exige uma mudança de mentalidade: a *habilidade* não é vista como um bloco monolítico de conhecimento, mas como um portal para um ecossistema de conhecimento. O projeto Heftes desempenha um papel crucial nesta visão, pois não apenas gera o núcleo da *habilidade*, mas também incentiva e facilita a criação de um ecossistema de conteúdo ao seu redor. Ao gerar um manifesto de conteúdo JIT com links bem formados, o Heftes contribui para a criação de *habilidades* que são não apenas funcionais, mas também educativas, colaborativas e de fácil manutenção. Esta abordagem prepara-se para o futuro, onde as *habilidades* podem evoluir para serem parte de uma web de conhecimento interligado, onde a informação é dinâmica, verificável e acessível a pedido.

## Síntese de Práticas Consolidadas: Um Quadro de Referência para a Geração de Habilidades

Com base na análise aprofundada da literatura acadêmica, das diretrizes de comunidades técnicas e dos mecanismos de extensibilidade observados nas diversas plataformas de CLI de IA, é possível sintetizar um conjunto de práticas consolidadas. Este quadro de referência não se destina a ser uma receita rígida, mas sim um conjunto de princípios orientadores e boas práticas que devem informar o design e a implementação de qualquer sistema para a geração de *habilidades*, como o projeto Heftes. Estas práticas foram validadas contra as fontes fornecidas e representam a sabedoria acumulada sobre como construir sistemas de agentes agênticos modulares, eficientes e seguros, com validade até 2026.

A primeira e mais fundamental prática é a **Conformidade com a Documentação Oficial**. Como estabelecido anteriormente, cada CLI de IA — seja Claude Code, GitHub Copilot, Gemini CLI ou uma ferramenta emergente — opera dentro de um ecossistema com suas próprias regras, protocolos e formatos de extensibilidade [[23](https://docs.github.com/en/copilot/how-tos/provide-context/use-mcp/use-the-github-mcp-server), [24](https://www.linkedin.com/posts/reidkimball_build-debug-deploy-with-ai-activity-7417322614400151552-ls2z), [27](https://www.linkedin.com/posts/throusse_everyone-customizing-claude-code-and-similar-activity-7419477521609662464-XEcp)]. Tentar impor um padrão universal é uma receita para a incompatibilidade. Em vez disso, o sucesso reside na capacidade de consumir as especificações oficiais (sejam elas documentos, RFCs ou códigos-fonte) e gerar artefactos que sejam fiéis a essas especificações. O projeto Heftes deve ser arquitetado como um motor de geração que utiliza "condutores" ou "plugins" para cada plataforma, garantindo que a saída seja sempre interoperável [[53](https://blakecrosley.com/en/guides/claude-code)].

A segunda prática é a **Estruturação Rigorosa com Metadados Abundantes**. Uma *habilidade* não é apenas código; é um artefacto descritivo. A utilização de um esquema de metadados abstrato, como o proposto com nove campos, fornece uma base sólida para a padronização [[70](https://mirrors.aliyun.com/pypi/simple/)]. No entanto, esta abstração deve ser suficientemente flexível para ser traduzida para os formatos específicos exigidos por cada plataforma (ex: `manifest.json` para Claude Code, configurações YAML para outras) [[27](https://www.linkedin.com/posts/throusse_everyone-customizing-claude-code-and-similar-activity-7419477521609662464-XEcp)]. Os metadados devem ir além de simples etiquetas; devem reificar a intenção da *habilidade*, descrevendo-a de forma autossuficiente em termos de autor, versão, dependências, licença e casos de teste [[2](https://dl.acm.org/doi/full/10.1145/3706598.3714259), [8](https://dl.acm.org/doi/full/10.1145/3468505)]. Esta abordagem transforma as *habilidades* em componentes de software verdadeiramente gerenciáveis e auditáveis.

A terceira prática é a **Organização Modular e a Implementação de Carregamento Sob-Demanda (JIT)**. A divisão da *habilidade* em um núcleo leve (metadados e lógica mínima) e um ecossistema de conteúdo complementar (exemplos, referências, tutoriais) é uma estratégia poderosa para otimizar o desempenho e a manutenção [[86](https://zhuanlan.zhihu.com/p/2002045828500575394)]. O carregamento JIT, implementado através de links para conteúdo externo armazenado em plataformas como o GitHub (*gists*, repositórios), permite que o agente carregue apenas o contexto necessário no momento, reduzindo a latência e o consumo de memória [[47](https://docs.github.com/en/enterprise-server@3.18/get-started/writing-on-github/editing-and-sharing-content-with-gists/creating-gists), [48](https://docs.github.com/en/enterprise-server@3.14/get-started/writing-on-github/editing-and-sharing-content-with-gists/saving-gists-with-stars)]. A implementação desta prática deve ser facilitada pelo sistema de geração, que deve ser capaz de gerar um manifesto de conteúdo JIT junto com a *habilidade*, garantindo que o material de apoio esteja sempre estruturado e acessível.

A quarta prática é a **Integração de Segurança e Verificabilidade por Padrão**. A exposição de ferramentas e a execução de código, especialmente com base em comandos de utilizador, introduzem riscos significativos. A literatura sobre ataques de injeção de comandos serve como um alerta crucial [[28](https://arxiv.org/html/2601.17548v1)]. Uma *habilidade* gerada de forma segura deve ser projetada com o princípio do menor privilégio, limitando o acesso a ficheiros e APIs. Além disso, o conteúdo complementar carregado sob demanda, especialmente o código, deve ser proveniente de fontes verificáveis. Encorajar o uso de *commits* assinados com GPG/SSH e *tags* assinados fortalece a cadeia de confiança, permitindo que o agente e o utilizador verifiquem a integridade e a origem do conteúdo [[41](https://docs.github.com/en/authentication/managing-commit-signature-verification/signing-commits), [44](https://docs.github.com/en/authentication/managing-commit-signature-verification/about-commit-signature-verification), [45](https://docs.github.com/en/enterprise-server@3.18/authentication/managing-commit-signature-verification/about-commit-signature-verification)]. O sistema Heftes pode ajudar neste aspecto gerando notas de utilizador com instruções sobre como assinar as suas contribuições.

A quinta e última prática é a **Adoção de Protocolos de Interoperabilidade Emergentes**. Embora não haja um padrão universal, a proliferação de protocolos como o Model Context Protocol (MCP) indica uma tendência para a padronização na interação entre agentes e ferramentas [[25](https://blog.csdn.net/EnjoyEDU/article/details/155378733), [69](https://www.53ai.com/news/LargeLanguageModel/2025040889057.html)]. Um sistema de geração de *habilidades* que entenda como gerar artefactos compatíveis com estes protocolos (por exemplo, servidores MCP) estará melhor posicionado para ser resiliente às mudanças futuras no ecossistema. A capacidade de gerar um cliente ou servidor MCP que implementa uma *habilidade* nativamente é uma forma avançada de garantir a interoperabilidade e de aproveitar as funcionalidades de orquestração e descoberta de ferramentas que estes protocolos proporcionam [[23](https://docs.github.com/en/copilot/how-tos/provide-context/use-mcp/use-the-github-mcp-server), [54](https://www.linkedin.com/posts/jeffreyemanuel_github-dicklesworthstonemcpagentmail-activity-7388557611622903808-oh0H)].

A tabela seguinte consolida estas cinco práticas num quadro de referência acionável:

| Prática Consolidada | Descrição Executiva | Benefícios Chave | Fontes de Influência |
| :--- | :--- | :--- | :--- |
| **Conformidade com Documentação Oficial** | Gerar artefactos que sejam fiéis às especificações de cada plataforma (CLI), utilizando drivers/plugins específicos. | Interoperabilidade, Funcionalidade Garantida, Manutenibilidade. | Documentação de Claude Code [[53](https://blakecrosley.com/en/guides/claude-code)], GitHub Copilot [[23](https://docs.github.com/en/copilot/how-tos/provide-context/use-mcp/use-the-github-mcp-server)], etc. |
| **Estruturação Rigorosa com Metadados** | Utilizar um esquema de metadados abstrato e flexível para descrever completamente a habilidade (intenção, dependências, etc.). | Auto-documentação, Descoberta, Reutilização, Auditoria. | Teorias de Interação Generativa [[8](https://dl.acm.org/doi/full/10.1145/3468505)], Instrumentos de IA [[2](https://dl.acm.org/doi/full/10.1145/3706598.3714259)]. |
| **Organização Modular e JIT** | Separar o núcleo da habilidade do seu conteúdo complementar, carregando este último sob-demanda via links. | Eficiência de Desempenho, Manutenibilidade, Colaboração. | Agent Skills [[86](https://zhuanlan.zhihu.com/p/2002045828500575394)], Jupybara [[4](https://dl.acm.org/doi/full/10.1145/3706598.3713913)]. |
| **Segurança e Verificabilidade por Padrão** | Projetar habilidades com segurança intrínseca e promover o uso de fontes verificáveis para o conteúdo complementar (ex: commits/tags assinados). | Mitigação de Riscos (ex: injeção), Confiança, Integridade. | Ataques de Injeção de Prompt [[28](https://arxiv.org/html/2601.17548v1)], Segurança de Software. |
| **Adoção de Protocolos de Interoperabilidade** | Gerar artefactos compatíveis com protocolos emergentes como o MCP para facilitar a interação e orquestração. | Resiliência a Mudanças, Escalabilidade, Integração Nativa. | MCP Deep Dive [[25](https://blog.csdn.net/EnjoyEDU/article/details/155378733)], MCP Explained [[69](https://www.53ai.com/news/LargeLanguageModel/2025040889057.html)]. |

Ao aderir a este quadro de referência, o projeto Heftes pode transcender a mera geração de código para se tornar uma ferramenta poderosa para a ecologia de desenvolvimento de agentes agênticos. Ele não apenas produz *habilidades* funcionalmente corretas, mas também promove a criação de um ecossistema de *habilidades* que são descritivas, seguras, eficientes e projetadas para o futuro. Esta abordagem holística é a chave para maximizar o valor e a sustentabilidade do projeto no panorama tecnológico em rápida evolução de 2026 e além.

## Arquitetura Proposta para um Sistema de Geração Automatizada de Habilidades (Heftes)

Com base nas melhores práticas e no quadro de referência consolidado, podemos agora propor uma arquitetura para o sistema Heftes. O objetivo é criar um motor de geração automatizada que seja flexível, escalável e orientado para a conformidade. A arquitetura proposta é modular, centrada em dados e projetada para operar sobre um esquema de metadados abstrato, gerando artefactos específicos para cada CLI de IA alvo. Esta abordagem permite que o sistema evolua à medida que novas plataformas emergem e as existentes mudam as suas especificações de extensibilidade.

O núcleo da arquitetura é um **Motor de Geração Centralizado**. Este motor recebe uma solicitação de criação de *habilidade* (por exemplo, a partir de um comando `/hefesto.create` num chatbot) e coordena todo o processo. A entrada para este motor é um objeto de dados que segue o esquema de metadados abstrato definido previamente. Este objeto de dados contém todas as informações necessárias para a *habilidade*: nome, descrição, lógica principal (provavelmente um script de prompt ou código), categorias, exemplos, referências, etc.

A principal componente do motor é o **Sistema de Templates e Drivers**. Em vez de um único conjunto de regras codificadas, o Heftes deve ser alimentado por um conjunto de templates e drivers que desacoplam a lógica de geração da especificação da plataforma.
1.  **Templates Abstratos:** Estes são os esquemas de metadados (ex: `skill.schema.yaml`) e os modelos de ficheiro (ex: `main.js.ejs` para JavaScript, `main.py.jinja` para Python) que definem a estrutura geral de uma *habilidade*. Eles usam variáveis que serão substituídas pelos dados da *habilidade*.
2.  **Drivers de Plataforma:** Estes são módulos específicos para cada CLI (ex: `driver-claudocode.js`, `driver-githubcopilot.py`, `driver-gemini-cli.ts`). Cada driver contém a lógica para traduzir o objeto de dados da *habilidade* do esquema abstrato para os formatos e convenções específicas da sua plataforma. Por exemplo, o `driver-claudocode.js` saberia como converter o campo `category` do nosso schema em uma entrada no `domains` do `manifest.json` [[27](https://www.linkedin.com/posts/throusse_everyone-customizing-claude-code-and-similar-activity-7419477521609662464-XEcp)]. Um novo driver pode ser adicionado para uma CLI emergente em 2026, permitindo que o sistema continue a operar sem alterações no motor central.

O fluxo de trabalho típico do Heftes seria o seguinte:
1.  **Início:** O utilizador inicia o processo, talvez através de um comando de interface de linha de comando ou de um bot de chat.
2.  **Coleta de Informações:** O Heftes interage com o utilizador para preencher o objeto de dados da *habilidade*. Pode fazer perguntas sobre a funcionalidade desejada, os gatilhos de palavra-chave, as dependências, etc., ou pode aceitar uma descrição textual e gerar os metadados preliminares.
3.  **Seleção da Plataforma:** O utilizador seleciona para qual(s) CLI(s) a *habilidade* deve ser gerada (ex: "Claude Code e GitHub Copilot").
4.  **Processamento pelo Motor:** O motor de geração centralizado assume o controlo. Ele itera sobre os drivers de plataforma selecionados.
5.  **Geração de Artefactos:** Para cada driver, o motor utiliza os templates abstratos e a lógica do driver para renderizar os ficheiros específicos da plataforma. Por exemplo, ele geraria `my-skill/skill.yaml`, `my-skill/manifest.json` (usando o driver Claude Code) e `my-skill/mcp_server.py` (usando o driver GitHub Copilot).
6.  **Geração do Manifesto JIT:** Simultaneamente, o motor geraria um manifesto de carregamento sob-demanda (ex: `my-skill/jit-manifest.json`). Este ficheiro seria preenchido com URLs para conteúdo complementar. Estas URLs poderiam ser geradas automaticamente a partir de links fornecidos pelo utilizador ou, de forma mais inteligente, o Heftes poderia ajudar a criar e partilhar este conteúdo. Por exemplo, ao encontrar um bloco de código nos exemplos, o Heftes poderia oferecer ao utilizador a opção de criar um *gist* do GitHub e inserir o link correspondente no manifesto.
7.  **Saída e Entrega:** O resultado final é um diretório compactado ou um repositório Git pronto a ser utilizado. O utilizador pode instalar a *habilidade* no seu ambiente local, seguindo as instruções da documentação da plataforma específica.

Para tornar o sistema ainda mais robusto e útil, a arquitetura deve incluir as seguintes funcionalidades adicionais:
*   **Validação de Metadados:** Antes de iniciar a geração, o sistema deve validar o objeto de dados da *habilidade* contra o schema abstrato para garantir que todos os campos obrigatórios estão presentes e corretamente formatados.
*   **Teste Integrado:** O sistema Heftes deve ser capaz de executar os casos de teste definidos nos metadados da *habilidade* para verificar a sua correção funcional. Isto pode ser feito compilando um script de teste minimalista que importa a lógica da *habilidade* e executa os testes definidos.
*   **Interface de Linha de Comando (CLI):** Um CLI próprio para o Heftes permitiria aos utilizadores executar o processo de forma não interativa, facilitando a integração em fluxos de trabalho de CI/CD.
*   **Suporte a Tipos de Habilidades:** A arquitetura deve ser flexível o suficiente para gerar diferentes tipos de *habilidades*, como scripts de invocação, servidores MCP completos, ou até mesmo pacotes de extensão para editores de código como o Cursor [[40](https://www.linkedin.com/posts/sonnylazuardi_just-wanted-to-share-my-latest-experiment-activity-7307821553654657024-yrh8)].

A seguir, apresentamos um diagrama de blocos simplificado da arquitetura proposta:

```
+---------------------+
|                     |
|  Interface do Utilizador   |
|  (Chat, CLI, UI Web)  |
|                     |
+----------+----------+
           |
           | Solicitação (/hefesto.create)
           v
+---------------------+
|                     |
|   Motor de Geração  |
|     Centralizado      |
|                     |
|  +---------------+  |
|  | Objeto de Dados |<-------------------------+
|  | da Habilidade   |                          |
|  +---------------+  |                          |
|  | - name        |  |                          |
|  | - description |  |                          |
|  | - ...         |  |                          |
|  +---------------+  |
|                     |
+----------+----------+
           |
           | Itera sobre Drivers
           v
+-----------------------------------------------------+
|                                                     |
|                  Drivers de Plataforma                |
|                                                     |
|  +--------------------+  +----------------------+   |
|  | Driver Claude Code |  | Driver GitHub Copilot|   |
|  | - traduz manifesto |  | - gera MCP Server    |   |
|  | - adapta metadados |  | - gera cliente       |   |
|  +--------------------+  +----------------------+   |
|                                                     |
+-----------------------------------------------------+
           |
           | Renderiza Templates
           v
+-----------------------------------------------------+
|                                                     |
|                 Sistema de Templates                  |
|                                                     |
|  +--------------------+  +----------------------+   |
|  | manifest.json.ejs  |  | main.py.jinja      |   |
|  | jit-manifest.json  |  | ...                |   |
|  +--------------------+  +----------------------+   |
|                                                     |
+-----------------------------------------------------+
           |
           | Saída Final
           v
+-----------------------------------------------------+
|                                                     |
|              Artefactos Gerados                     |
|                                                     |
|  skills/my-awesome-skill/                           |
|  ├── skill.yaml               (Schema Abstrato)      |
|  ├── manifest.json            (Gerado pelo Driver)   |
|  ├── mcp_server.py            (Gerado pelo Driver)   |
|  ├── jit-manifest.json        (Gerado pelo Motor)    |
|  └── content/                 (Links para conteúdo)  |
|                                                     |
+-----------------------------------------------------+
```

Em conclusão, a arquitetura proposta para o sistema Heftes é um sistema modular, orientado por dados e centrado na conformidade. Ao adotar um modelo de motor com condutores e templates, o sistema torna-se flexível e escalável, capaz de se adaptar à diversidade e à evolução do ecossistema de CLIs de IA. Ao integrar explicitamente as melhores práticas de estruturação de metadados, organização modular e carregamento sob-demanda, o Heftes não apenas gera *habilidades* que funcionam, mas gera *habilidades* que são robustas, seguras e projetadas para serem parte de uma ecologia de conhecimento colaborativa e sustentável.