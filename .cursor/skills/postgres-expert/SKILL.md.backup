---
name: postgres-expert
description: |
  Guides advanced PostgreSQL design and operations including schema modeling, indexing, transaction isolation, query plans, partitioning, replication, and maintenance.
  Use when: designing or tuning relational workloads on PostgreSQL, diagnosing performance issues, or defining robust operational standards for production databases.
---

# PostgreSQL Expert

PostgreSQL evolved from academic origins to one of the most capable open-source relational databases, with strong SQL compliance and extensibility. This skill helps the agent make production-grade decisions across modeling, performance, and operations.

## How to model schemas for long-term maintainability

1. Model aggregates and constraints from business invariants first.
2. Use clear primary/foreign key strategy and naming conventions.
3. Keep nullable columns intentional and documented.
4. Apply migrations incrementally with backward-compatible steps.

## How to choose and tune indexes

1. Start with query patterns, then design indexes.
2. Use B-tree for common equality/range filters.
3. Use GIN/GiST for JSONB/full-text/specialized search patterns.
4. Remove unused or redundant indexes to reduce write overhead.

## How to tune query performance with plans

1. Analyze critical queries using `EXPLAIN (ANALYZE, BUFFERS)`.
2. Identify sequential scans, bad estimates, and join mischoices.
3. Refresh statistics with `ANALYZE` and tune autovacuum.
4. Rewrite queries or indexes based on measured bottlenecks.

## How to manage transactions and isolation

1. Use shortest transaction scope possible.
2. Select isolation level by consistency requirements.
3. Design retry logic for serialization/deadlock scenarios.
4. Keep lock order consistent to reduce contention.

## How to scale with partitioning and replication

1. Partition large tables by access pattern (time, tenant, region).
2. Use read replicas for scale-out read paths.
3. Plan failover procedures and RPO/RTO targets explicitly.
4. Test backup/restore and failover drills regularly.

## How to run healthy production maintenance

1. Monitor vacuum, bloat, replication lag, and connection saturation.
2. Tune `work_mem`, `shared_buffers`, and connection pools with evidence.
3. Keep schema and statistics maintenance in release runbooks.
4. Enforce least-privilege roles and audited admin workflows.

## Common Warnings & Pitfalls

- Creating indexes reactively without workload analysis.
- Long idle transactions blocking vacuum progress.
- Underestimating autovacuum impact on table health.
- Relying on app-level uniqueness without DB constraints.
- Ignoring replica lag for read-after-write expectations.

## Common Errors and Fixes

| Symptom | Root Cause | Fix |
|---|---|---|
| Query suddenly slow after data growth | Outdated plan/index mismatch | Re-run plan analysis and adjust index/query strategy |
| Deadlock errors under load | Conflicting lock order | Standardize lock acquisition order and add retry policy |
| Table bloat increasing | Vacuum not keeping up | Tune autovacuum and schedule maintenance operations |
| Connection exhaustion | Too many app connections | Add pooler strategy and right-size max connections |

## Advanced Tips

- Use partial indexes for sparse high-value predicates.
- Consider BRIN indexes for very large append-only tables.
- Adopt online migration patterns for zero-downtime changes.
- Keep a performance baseline before and after each release.

## Version History and Usage Divergences

| PostgreSQL Version | Key Change | Practical Divergence |
|---|---|---|
| 12 | CTE inlining behavior changed | Previously optimization-fenced queries became planner-optimized |
| 13 | Better btree dedup and planner improvements | Different index/storage behavior under heavy duplicate keys |
| 14-16 | Performance, logical replication, and SQL feature evolution | Upgrade planning required for extension compatibility and tuning defaults |

## Java and Kotlin Usage Examples

```java
HikariConfig cfg = new HikariConfig();
cfg.setJdbcUrl(jdbcUrl);
cfg.setMaximumPoolSize(20);
cfg.setConnectionTimeout(3000);
DataSource ds = new HikariDataSource(cfg);
```

```kotlin
@Transactional(readOnly = true)
fun findOpenInvoices(limit: Int): List<InvoiceDto> =
  jdbcTemplate.query(
    "select id, total from invoice where status = 'OPEN' order by created_at desc limit ?",
    { rs, _ -> InvoiceDto(rs.getLong("id"), rs.getBigDecimal("total")) },
    limit
  )
```

## Expert Techniques

- Use `EXPLAIN (ANALYZE, BUFFERS, WAL)` for write-heavy troubleshooting, not only read plans.
- Combine partial indexes with predicate-stable query contracts.
- Track bloat trend and autovacuum lag as first-class SLO signals.
- Use lock graph analysis (`pg_locks`) during deadlock/perf incidents.
## References

- [PostgreSQL Documentation](https://www.postgresql.org/docs/)
- [PostgreSQL Performance Tips](https://www.postgresql.org/docs/current/performance-tips.html)
- [PostgreSQL EXPLAIN](https://www.postgresql.org/docs/current/using-explain.html)
- [PostgreSQL Monitoring Statistics](https://www.postgresql.org/docs/current/monitoring-stats.html)


