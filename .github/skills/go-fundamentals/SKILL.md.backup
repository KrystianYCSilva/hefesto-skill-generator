---
name: go-fundamentals
description: |
  Guides Go fundamentals for backend systems including package design, error handling, context propagation, concurrency patterns, and testing strategy.
  Use when: building or reviewing Go services, improving reliability in concurrent code, or establishing idiomatic Go standards in backend projects.
---

# Go Fundamentals

Go was designed for simple, maintainable systems programming with first-class concurrency and fast builds. This skill helps the agent apply idiomatic Go patterns for robust backend services.

## How to structure packages and modules

1. Use Go modules as dependency boundaries.
2. Keep package APIs small and cohesive.
3. Organize by domain responsibility instead of technical layers only.
4. Avoid public exports unless required by other packages.

## How to handle errors idiomatically

1. Return errors as values and handle them close to the source.
2. Wrap errors with context using `%w`.
3. Use sentinel errors sparingly and document their meaning.
4. Avoid panic for expected operational failures.

## How to use context and cancellation correctly

1. Pass `context.Context` as first parameter on request-scoped operations.
2. Enforce timeouts/deadlines for outbound calls.
3. Stop goroutines when context is canceled.
4. Avoid storing context in structs.

## How to design safe concurrency

1. Use goroutines only with explicit lifecycle ownership.
2. Use channels for coordination, not as global event buses.
3. Protect shared state with mutexes where appropriate.
4. Prefer simple patterns before advanced synchronization primitives.

## How to test and observe Go services

1. Use table-driven tests for behavior coverage.
2. Separate fast unit tests from integration tests.
3. Add benchmarks for hot paths before optimization.
4. Include structured logs and metrics for operational visibility.

## Common Warnings & Pitfalls

- Goroutine leaks due missing cancellation paths.
- Ignored errors in I/O and network code.
- Overusing channels where plain function calls are clearer.
- Global mutable state causing race conditions.
- Premature micro-optimizations without profiling.

## Common Errors and Fixes

| Symptom | Root Cause | Fix |
|---|---|---|
| Rising memory usage over time | Goroutine/resource leak | Add cancellation, close resources, and inspect with profiling tools |
| `context deadline exceeded` frequently | Timeout too low or downstream latency spikes | Rebalance timeout budgets and optimize downstream call chain |
| Data race in tests | Unsynchronized shared state | Run with race detector and protect critical sections |
| Module import chaos | Inconsistent module/version management | Normalize `go.mod` dependencies and tidy regularly |

## Advanced Tips

- Use `pprof` and tracing before deep performance changes.
- Keep interfaces small and defined by consumers.
- Build resilience wrappers for outbound dependencies.
- Add chaos/failure tests for critical concurrent workflows.

## Version History and Usage Divergences

| Go Version | Key Change | Practical Divergence |
|---|---|---|
| 1.18 | Generics introduced | API design shifted from interface-heavy patterns to constrained type params |
| 1.20+ | Runtime/toolchain and stdlib improvements | Error handling and performance tuning practices evolved |

## Java and Kotlin Integration Examples

```yaml
# Service interoperability pattern
Go service (gRPC/OpenAPI) <-> Spring Boot/Ktor clients with generated contracts
```

```go
ctx, cancel := context.WithTimeout(parentCtx, 2*time.Second)
defer cancel()
resp, err := client.Do(req.WithContext(ctx))
```

## Expert Techniques

- Run race detector in CI for all concurrency-heavy packages.
- Use `pprof` before tuning allocations; avoid blind `sync.Pool` usage.
- Keep goroutine ownership explicit and test cancellation propagation paths.
- Use backpressure-aware worker pools instead of unbounded goroutine fan-out.
## References

- [Go Documentation](https://go.dev/doc/)
- [Effective Go](https://go.dev/doc/effective_go)
- [Go Blog](https://go.dev/blog/)
- [Go Concurrency Patterns](https://go.dev/talks/2012/concurrency.slide)


